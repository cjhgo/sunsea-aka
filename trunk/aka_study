============================================================================================================================================================================
linux

1、http://lxr.linux.no/+trees	在线读linux源码

2、常用操作
	cp命令
		




============================================================================================================================================================================
vim操作

1、查看宏定义
	［ ＋ d

2、查询函数
	shift ＋ 3

3、:后边加行号就是跳到这一行
   <C-O> 光标返回到以前的位置。相当于光标移动的“撤销”
   <C-I> 光标返回到后来的位置。相当于光标移动的“恢复”

4、如何返回开头、结尾？
	开头：按两次g（小写）
	结尾：按一次G（大写）

5、如何同时给每行第一个位置加"*"？
	1.光标移动到开始需要添加"*"的那一行
	2.按ctrl+v（小写），此时的模式是：可视 块
	3.按I（大写）
	4.输入*（需要在每一行加入的字符，也可以多个字符）
	5.按ESC

6、从别处复制过来的代码，粘贴在vim中往往排版很乱，如何自动排版？
	选中要进行排版的文档，按=即可
	另外：< 代表往左缩进，> 代表往右缩进

7、对文档加密
	退出前，输入"：X"，这时会提示出入密码，然后提示请再输入一次，然后退出文档，下次再使用文档时，必须输入密码才能打开
	删除密码：退出前，输入"：X"，这时让输入密码，我们不输入直接回车，然后提示请再输入一次密码，我们不输入直接回车，然后退出，这时密码就删除了。

============================================================================================================================================================================
c语言

char *p = "hello world"; 能否把h小写改成大写H？有办法么？不能修改，因为"hello world"认为该字符串是只读的，不允许修改。

清空缓冲区
setbuf(stdin, NULL);



============================================================================================================================================================================
c语言文件操作

fopen()
	打开文件
	fopen("test.txt", "r")	//test.txt在当前目录下，如果不在当前目录下，要使用绝对路径"~/term6/1019/test.txt";	"r"是文件只读
	使用fopen()最好对fopen()的返回值进行判断，一般使用如下格式：
	if((fp = fopen("test.txt", "r")) == NULL)
	{
		perror("test.txt");			//打印错误信息，比如会打印test.txt: No such file or directory
		exit(0);
	}
	
	r	打开只读文件，该文件必须存在。
	r+	打开可读写的文件，该文件必须存在。
	rb+	读写打开一个二进制文件，只允许读写数据。
	rt+	读写打开一个文本文件，允许读和写。
	w	打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
	w+	打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
	a	以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）
	a+	以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）
	wb	只写打开或新建一个二进制文件；只允许写数据。
	wb+	读写打开或建立一个二进制文件，允许读和写。
	wt+	读写打开或着建立一个文本文件；允许读写。
	at+	读写打开一个文本文件，允许读或在文本末追加数据。
	ab+	读写打开一个二进制文件，允许读或在文件末追加数据。 

fclose()
	关闭文件
	用法：	fclose(fp);

fputc()
	往fp文件中写入一个字符

fgetc()
	从fp中读取一个字符到char ch

fputs()
	往fp文件中写入一个字符串

fgets()
	从流中读一行或指定个字符,原型是char *fgets(char *s, int n, FILE *stream);   只能读取n-1个

	fgets函数的调用形式如下：fgets（str，n，fp）；
	此处，fp是文件指针；str是存放在字符串的起始地址；n是一个int类型变量。
	函数的功能是从fp所指文件中读入n-1个字符放入str为起始地址的空间内；
	如果在未读满n-1个字符之时，已读到一个换行符或一个EOF（文件结束标志），则结束本次读操作，读入的字符串中最后包含读到的换行符。
	因此，确切地说，调用fgets函数时，最多只能读入 n-1个字符。读入结束后，系统将自动在最后加'\0'，并以str作为函数值返回。

fwrite()
	向文件读入写入一个数据块
	fwrite(const void*buffer,size_t size,size_t count,FILE*stream);
	（1）buffer：是一个指针，对fwrite来说，是要输出数据的地址。
	（2）size：要写入的字节数；
	（3）count:要进行写入size字节的数据项的个数；
	（4）stream:目标文件指针。 

fread()
	从一个流中读数据
	函数原型: int fread(void *ptr, int size, int nitems, FILE *stream);
	参 数：用于接收数据的地址（指针）（ptr）
	单个元素的大小（size） ：单位是字节而不是位，例如读取一个整数值就是4，读取一个字符型就是1，size就是每次要读的长度。
	元素个数（nitems）：要进行读取多少次，假如nitems ＝ 5，意味着每次读取size个字节的单元，重复读取5次，当然每重复一次都是紧从上一次末尾开始读取。
	提供数据的文件指针（stream）
	返回值：成功读取的元素个数，返回值并不是完全等于nitems，如果nitems ＝ 1024，而实际上文件只有100个字节，则fread的返回值就是100，而不是1024。
		特殊情况	1、	假如size ＝ 1024，nitems ＝ 1，而你的文件长度只有100个，这时会发现结果是读出来，
				但是返回值确是0，原因是，我们要求他一次读取1024个，但是他确只能读取100个，他没有成功1024个字节，所以返回值是0。
		特殊情况	2、	假如文件只有3个字符aaa，我们让size ＝ 1，nitems ＝ 10，此时返回值是4，
				原因是，在文件中aaa之后还有一个\n，所以会返回值 ＝ 4，尽管我们只看到了3个a，因为\n我们是看不到的。

fprintf()
	传送格式化输出到一个文件中
	int fprintf( FILE *stream, const char *format, ... );
	fprintf()函数根据指定的format(格式)(格式)发送信息(参数)到由stream(流)指定的文件. fprintf()只能和printf()一样工作. fprintf()的返回值是输出的字符数,发生错误时返回一个负值.
	fprintf( fp, "%s%c", s, c ); 

fscanf()
	从一个流中执行格式化输入
	int fscanf(FILE *stream, char *format,[argument...]);
	fscanf( fp, "%s", s ); 

rewind()
	将文件内部的位置指针重新指向一个流（数据流/文件）的开头
	注意：不是文件指针而是文件内部的位置指针，随着对文件的读写文件的位置指针（指向当前读写字节）向后移动。而文件指针是指向整个文件，如果不重新赋值文件指针不会改变。

fscanf()
	从一个流中执行格式化输入 
	int fscanf(FILE *stream, char *format,[argument...]); 
	fscanf(fp, "%s", stdout);
	注意：如果fp文件中有空格换行回车，则fscanf遇到空格换行回车就停止输入了

fprintf()
	传送格式化输出到一个文件中
	int fprintf( FILE *stream, const char *format, ... ); 

读/写函数的选用原则 :
	从功能角度来说，fread()和fwrite()函数可以完成文件的任何数据读／写操作。 
	但为方便起见，依下列原则选用： 
	1．读/写1个字符（或字节）数据时：选用fgetc()和fputc()函数。 
	2．读/写1个字符串时：选用fgets()和fputs()函数。 
	3．读/写1个（或多个）不含格式的数据时：选用fread()和fwrite()函数。 
	4．读/写1个（或多个）含格式的数据时：选用fscanf()和fprintf()函数。

fseek()
	重定位流(数据流/文件)上的文件内部位置指针
	注意：不是定位文件指针，文件指针指向文件/流。位置指针指向文件内部的字节位置，随着文件的读取会移动，文件指针如果不重新赋值将不会改变指向别的文件。 
	int fseek(FILE *stream, long offset, int fromwhere);
	第一个参数stream为文件指针
	第二个参数offset为偏移量，正数表示正向偏移，负数表示负向偏移
	第三个参数origin设定从文件的哪里开始偏移,可能取值为：SEEK_CUR、 SEEK_END 或 SEEK_SET
	SEEK_SET： 文件开头
	SEEK_CUR： 当前位置
	SEEK_END： 文件结尾
	其中SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2.
	简言之：
	fseek(fp,100L,0);把fp指针移动到离文件开头100字节处；		如果文件内容是abcdefghijk；fseek(fp, 3, 0)后，读出是：defghijk
	fseek(fp,100L,1);把fp指针移动到离文件当前位置100字节处；
	fseek(fp,100L,2);把fp指针退回到离文件结尾100字节处。
	函数设置文件指针stream的位置。
	如果执行成功，stream将指向以fromwhere（偏移起始位置：文件头0，当前位置1，文件尾2）为基准，偏移offset（指针偏移量）个字节的位置。
	如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。




============================================================================================================================================================================
sqlite3

1、创建数据库文件:
	SQLite3 d:\test.db 回车
	就生成了一个test.db在d盘。
	这样同时也SQLite3挂上了这个test.db

2、看看目前的数据库
	>.database  
		
3、创建表
	create table term5(id integer primary,name text);

4、自动增长列
	autoincrement

5、查看所有表
	.tables

	SELECT name FROM sqlite_master
	WHERE type='table'

6、查看表结构
	.schema			显示所有表结构
	.schema	term5		显示指定term5的表结构

7、向表中插入某一列
	alter term5 add age integer;

8、重命名表的名字
	alter table t1 rename to t2;

9、删除表
	drop table term5;

10、查询表中所有信息
	select * from term5;

11、查询表中指定信息
	select name from term5;
	select name from term5 where id = 1;
	select name from term5 where name like "z%";

12、添加表中的信息
	insert into term5 values (2,"lisi",19);

13、删除表中的数据
	delete from term5 where id = 2;

14、更新表中的数据
	update term5 set name = "zsx" where name = "zhangsan";

15、更换|符号
	.separator ","

16、文件编译
	gcc sqlite_zsx.c -lsqlite3		//-lsqlite3不能缺少

17、执行 SQL 语句

       typedef int (*sqlite_callback)(void*,int,char**, char**);
       int sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void*, char**);



============================================================================================================================================================================
其他
	用gcc编译含有数学公式的c文件需要加  -lm

============================================================================================================================================================================
20101014
1、return的学习
	在C语言的main函数中我们通常使用return (0);这样的方式返回一个值。
	return 表示从被调函数返回到主调函数继续执行，返回时可附带一个返回值，由return后面的参数指定。
	return通常是必要的，因为函数调用的时候计算结果通常是通过返回值带出的。
	如果函数执行不需要返回计算结果，最好用return;这样书写，显得程序书写完整。

2、exit的学习
	exit()通常是用在子程序中用来终结程序用的，使用后程序自动结束，跳出操作系统。
	exit(0) 表示程序正常退出
	exit(1)/exit(-1)表示程序异常退出。
	exit() 结束当前进程/当前程序/，在整个程序中，只要调用 exit ，就结束。 
3、sizeof与strlen的区别
	sizeof
		C语言中判断数据类型长度符
		sizeof()不是一个函数，在程序编译时就确定sizeof的值，同一个程序，不同的编译环境 sizeof的有可能不同
	strlen
		strlen所作的仅仅是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，
		直到碰到第一个字符串结束符'\0'为止，然后返回计数器值。
		根据'\0'判断是否因该结尾。
		strlen是一个函数。
			原型：unsigned int strlen(char *s);
			头文件：string.h
			功能：计算字符串s的(unsigned int型）长度
			说明：返回s的长度，不包括结束符NULL。
	
4、判断字符串是否结束，最好用'\0'为依据

5、今天用到的函数
	strcmp()
	原型：int strcmp(const char *s1, const char * s2); 
	返回值：
	ret = 0;	s1 = s2;
	ret > 0;	s1 > s2;
	ret < 0;	s1 < s2;

	strncmp()
	原型：int strncmp(const char *s1, const char * s2, int n); 

6、其他
	1、能独立出函数的尽量独立出函数
	2、每个函数功能尽可能最小化，尽最大可能单一。
============================================================================================================================================================================
20101015

1、static的用法
	1)、在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
	2)、在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
	3)、在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
	
	(以上内容只是自己每天学习总结，如有不正确的，请多多指正！	－－sunsea1026)
============================================================================================================================================================================
20101017

1、排序算法小结（冒泡排序、简单选择排序、快速排序）

	1）冒泡排序bubble_sort
		1.原理
			假设对a［N］进行排序
			依次比较相邻两个数，小数放前，大数放前。
			＊1	从头开始进行第一轮比较，则得到最后一个位置是所有数中的最大的一个数；		
				需要比较的次数是N－1，为什么是N－1？因为，总共是N个数，数组下标是从0开始，
				如果比较最后两个数据，判断条件：if(a[N-1-1] > a[N-1]),a[N-1]就是数组的最后一个数了，
				如果比较次数是N，则执行该论最后一对数据比较时就是if(a[N-1] > a[N]),
				众所都知，a[N]中是没有a[N]，所以次数会得到一个意想不到的排序，里面会多一个垃圾值，垃圾值的产生就是a[N]。
				所以此时必须用N－1。
			＊2	从头开始进行第二轮比较，则得到倒数第二个位置是所有数中的次最大数；		
				需要比较的次数是（N－1）－1，为什么是（N－1）－1？因为，解释同上。
			＊3	从头依次进行第三轮比较，则得到倒数第三个位置是所有数中的次次最大数；		
				需要比较的次数是N－1－1－1，为什么是（N－1）－1－1？因为，解释同上。
			＊N-1	依次从头开始比较，直至比较完。
		2.代码实现过程
			void bubble_sort(int a[], int N)			//N是数组a的长度
			{
				int i, j, tmp;

				for(i = 0; i < N-1; i++)			//进行比比较的趟数，此时的N－1如果换成N，对程序影响不大，只不过多一次循环而已
				{
					for(j = 0; j < N-i-1; j++)		//开始进行比较，此时的N－i－1不能换成N－i，如果写成N－i，会产生一个垃圾值，解释在＊1中
					{
						if(a[j] > a[j+1])
						{
							tmp    = a[j];
							a[j]   = a[j+1];
							a[j+1] = tmp;
						}
					}
				}
				
				return;
			}
	
	2）简单选择排序select_sort
		1.原理
			假设对a[N]进行排序
			假定选一个最小的，依次把后面的数与它进行比较，如果后面的比假定选的最小的还小，则进行交换这两个数。每进行一轮就要找出一个最小的数。
			＊1	第一轮	假定第一个数是“最小的”，然后依次把后面的数与这个“最小的”的进行比较，如果比这个“最小的”小，首先标记该数为“最小的”，
					然后把这个“最小的”与前面的“最小的”交换值，目的是保证第一个数是后面所有数中最小的一个。
			＊2	第二轮	因为已经知道第一个是最小的，这时从第二个开始寻找最小的，假定第二个是最小的，然后依次把后面的数与这个“最小的”的进行比较，
					如果比这个“最小的”小，首先标记该数为“最小的”，然后把这个“最小的”与前面的“最小的”交换值，目的是保证第二个数是后面所有数中最小的一个。

			＊N	第N轮	步骤同上。
			
			说明	是进行N轮比较还是N－1轮比较，影响不大，原因是：该数组中共有N个数，如果对N－1个数进行了排序处理，即第N－1个数是后面中最小的一个数，
				剩余的唯一的第N个数肯定是所有数中最大的，显然它应该放在最后一个位置上，没必要再进行一次循环。如果是进行N轮比较，无非是程序多执行一次循环，
				其实实际上这次循环也没有执行，因为在子循环中无法满足循环条件，不能执行循环体。

		2.代码实现过程
			void select_sort(int a[], int N)		//N是数组a的长度
			{
				int i, j, min, tmp;

				for(i = 0; i < N; i++)			//从头开始比较
				{
					min = i;			//把第i个数当作最小的，把下标标记为min
					for(j = i+1; j < N; j++)	//把a[min]依次和它后面的数进行比较
					{
						if(a[j] < a[min])	//如果后面的某个值比a[min]小
						{
							min = j;	//重新标记最小值下标
						}
						tmp = a[min];		//交换
						a[min] = a[i];		//原来min = i的，如果没有找到比a[min]小的，就不进行交换（如果没找到，i还是和min一样，执行该三条语句没作用）
						a[i] = tmp;		//只有a[j] < a[min]成立，执行了min = j，这时才能交换（这时min的已经改为j，不再是i了，所以执行才有作用）
					}				//自己表达欠缺，上面三句表达不够明确，只要自己研读程序，因该能明白其中奥妙
				}

				return;
			}

	3）快速排序quick_sort
		1.原理
			假定对a[N]排序
			快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。
			实现快速排序需要两个函数，分别是：partition()和quick_sort()
			
			函数：			int partition(int a[], int i, int j)
			函数功能：		把数组分为两段，左段都是比基准小的数，但是左段的数是无序的；右段都是比基准大的数，但是右段的数是无序的。
			函数大概实现过程：		
					*1	选取一个基准(pivot)，基准一般选取第一个数a[0];

					*2	定义两个变量i、j；
						令j从数组尾部向左扫描，直到遇到一个数比基准小的，进行交换。目的是：使比基准小的都放在基准左边。
						令i从数组开头向右扫描，直到遇到一个数比基准大的，进行交换。目的是：使比基准大的都放在基准右边。
						进行多次循环后，最终i的值就是基准应该放的位置。
						原因是：我们假定的基准是数组的第一个数a[0]，a[0]也许既不是数组中最大的数也不是数组中最小的数，
						也就是基准的位置应该在数组中的某个位置，经过多次循环后，i不断往后递增，当不满足循环条件时，i就停止了，此时i就是基准的位置
						（表达欠缺，还需要自己揣摩）
				
			函数：			void quick_sort(int a[], int left, int right)
			函数功能：		实现排序
			函数大概实现过程：
						递归的对每一段进行排序

		2.代码实现过程
			int partition(int a[], int i, int j)
			{			
				int pivot;				//基准
		
				pivot = a[i];				
				while(i < j)
				{
					while(i < j && a[j] > pivot);	
					{
						j--;			//如果右边的比基准大，左移j
					}
					a[i] = a[j];			//如果遇到了右边的比基准小，和基准交换
				
					while(i < j && pivot <= a[i]);
					{
						i++;			//如果左边的基准小，右移i
					}
					a[j] = a[i];			//如果遇到了左边的比基准大，和基准交换
				}
				a[i] = pivot;

				return i;
			}

			void quick_sort(int a[], int left, int right)
			{
				int pivottag;
			
				if(left < right)
				{
					pivottag = partition(a, left, right);
					quick_sort(a, 0, pivottag-1);	
					quick_sort(a, pivottag+1, right);
				}

				return;
			}


	(以上内容只是自己每天学习总结，如有不正确的，请多多指正！	－－sunsea1026)
============================================================================================================================================================================
20101018

1、strstr函数学习
	功能:	在串中查找指定字符串的第一次出现
	用法:	char *strstr(char *str1, char *str2);
	原型：	extern char *strstr(char *haystack, char *needle);
	用法：	#include <string.h>
	功能：	从字符串haystack中寻找needle第一次出现的位置（不比较结束符NULL)。
	说明：	返回指向第一次出现needle位置的指针，如果没找到则返回NULL。

2、vim技巧学习
	1、查找某个单词
		在ESC模式下，输入/printf（printf就是我们要查找的东西）,回车，此时，会找到一个printf，如果继续寻找往下寻找,输入n；如果往上寻找，输入N。

	(以上内容只是自己每天学习总结，如有不正确的，请多多指正！	－－sunsea1026)

============================================================================================================================================================================
20101023

1、如何在ubunut下管理googlecode？
	前些日子，看到徐老师使用googlecode，自己很感兴趣，于是自己也注册了一个，注册是个很简单的事情，但是注册好了，一直找不到管理googlecode的方法，经过网上大量搜索信息，学会了在windowns下如何去管理googlecode，其实很简单，只要下载一个工具即可，该工具的名称叫做“TortoiseSVN”安装好之后，右击鼠标就会看到，如何对其操作还是不会，还可以右击鼠标，TortoiseSVN－>版本库浏览器，这是个图形画界面，很直观。多接触下，多练习就会上手了。但是我大多数时间都是在用ubuntu操作系统，如果想更新googlecode必须要去windows下，让我很不爽，于是网上再次寻找资料，继续学习，终于找出了一条ubuntu下管理googlecode道路，现在仅仅学会了一些简单操作，拿出与大家分享下，如有不正确、不足的地方，请多多指正！
	
	1、安装svn（subvertion）
		sudo apt-get install subversion

	2、打开自己的googlecode代码库，在主页中，选择source，然后点击checkout，会看到两行内容
		svn checkout https://xxx.googlecode.com/svn/trunk/ xxx --username name
		svn checkout http://xxx.googlecode.com/svn/trunk/ xxx-read-only
		我对这两行的理解：
			第一行：是我们googlecode管理员的对gooelcode代码库管理的链接，通过此链接我们可以对我们的代码库进行更新。
			第二行：是所有人的阅读我们代码的链接，通过第二行的链接可以对我们代码库的所有内容进行阅读，但是无法更新其内容。

	3、用户名和密码的问题
		用户名就是我们的用户名，没有疑问，密码并不是我们gmail的密码，这个密码而是googlecode中给我们生成的密码，
		查看方式：进入我们googlecode主页，source，checkout，注意这一行内容“When prompted, enter your generated googlecode.com password.”
		点击蓝色部分就会看到我们需要的密码。

	4、复制第一行所有内容，即：svn checkout https://xxx.googlecode.com/svn/trunk/ xxx --username name到终端下，
		这时会在我们本地建一个代码库，一般在主文件夹下，名字一般是前面链接中的XXX，如果googlecode中有东西，在本地XXX目录中也会有相应的内容。

	5、添加新内容到我们的googlecode
		把我们需要上传的内容，复制到XXX中，然后执行命令：svn add *（*代表添加所有内容，如果不用*，上传单个文件也可以svn add test），
		这时，会列出我们所有要上传的内容，每一行前面都会有一个A,代表这是新添加的，到现在我们还没有真正的上传到googlecode，还差一个提交命令，
		再执行提交命令前，我们可以现看看我们要提交什么东西，使用这个命令：svn st(st是status的简写),这时会告诉我们要对哪些文件进行什么操作，
		加入发现我们不想提交test文件，我们就要取消他,执行：svn revert test,如果取消全部，执行：svn revert *，假如我们发现将要提交的内容没问题，
		我们执行命令:svn ci -m "说明信息"，这个时候会把内容提交至googlecode了。

	6、删除googlecode中内容
		首先先执行：svn up会获取googlecode的最新内容，然后执行：svn delete test.c(test.c就是要删除的内容)，
		最后还要进行提交，执行：svn ci -m ""，这时过哦哦过了code中的test.c已经被删除了。

	7、常用命令总结：
		svn checkout https://xxx.googlecode.com/svn/trunk/ xxx --username name		创建本地代码仓库
		svn up										获取最新版本
		svn add *									添加内容		
		svn delete *									删除内容
		svn revert *									撤销操作，比如add，delete等操作
		svn st										查看svn状态，一般在svn ci -m ""操作前用
		svn log										查看版本日志
		svn info									查看基本信息
		其他命令也可以查看svn帮助文档，查看帮助文档方法，在终端下，执行：svn ?

	8、几点说明：
		我学习googlecode参考了一些网上资料，上面的几点内容都是我网上学得，然后根据自己学习体会总结的几点，他们分别是：
		注册googlecode：			http://www.cnblogs.com/shukunwang
		windows下管理googlecode：	http://www.uml.org.cn/pzgl/200904246.asp
		ubuntu下管理googlecode：		http://saw-unix.com/2010/07/linux_google_code_subversion.html
		电子书：				《采用Subversion进行版本控制(中文).pdf》（下载地址：http://code.google.com/p/sunsea-aka/downloads/list）

============================================================================================================================================================================
20101027

1、字符串内容再学习
	1、什么情况下字符串中会自动添加'\0'?
		以下三种情况会自动添加'\0'：
		1）定义一个字符指针，并对其进行初始化，此时会自动添加'\0'；
		2）定一个字符数组，并未指定数组长度，对其初始化会自动添加一个'\0';		
		3）定一个字符数组，数组的长度大于初始化内容的长度，此时会自动添加'\0'；
	2、sizeof与strlen的问题
		char buf[] = "12345";

		printf("%d\n", sizeof(buf));		//6
		printf("%d\n", strlen(buf));		//5
		printf("%d\n", sizeof(p));		//4
		printf("%d\n", strlen(p));		//5

		说明：strlen只认'\0'为结束符，如果找完了buf还找不到'\0'，此时回去内存中的别的位置去找'\0'，直到找到'\0'才结束，
			所以如果buf中没有'\0'，打印该字符串时，会在打印完buf中的数据还会打印出其他乱码。

2、GDB学习
	



















